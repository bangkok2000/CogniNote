package com.cogninote.app.presentation.ui.screens.simplified

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.text.BasicTextField
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.focus.FocusRequester
import androidx.compose.ui.focus.focusRequester
import androidx.compose.ui.graphics.SolidColor
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.input.TextFieldValue
import androidx.compose.ui.unit.dp
import androidx.lifecycle.compose.collectAsStateWithLifecycle
import com.cogninote.app.presentation.viewmodel.NoteEditViewModel
import com.cogninote.app.data.entities.SimpleNoteType
import kotlinx.coroutines.delay

@Composable
fun SimpleNoteEditScreen(
    viewModel: NoteEditViewModel,
    noteId: String?,
    onSaveComplete: () -> Unit
) {
    val currentNote by viewModel.currentNote.collectAsStateWithLifecycle()
    val isLoading by viewModel.isLoading.collectAsStateWithLifecycle()
    
    var title by remember { mutableStateOf("") }
    var content by remember { mutableStateOf("") }
    var showNoteTypeDialog by remember { mutableStateOf(noteId == null) }
    
    val titleFocusRequester = remember { FocusRequester() }
    val contentFocusRequester = remember { FocusRequester() }
    
    // Load existing note or prepare for new note
    LaunchedEffect(noteId) {
        if (noteId != null) {
            viewModel.loadNote(noteId)
        } else {
            viewModel.createNewNote()
        }
    }
    
    // Update local state when note loads
    LaunchedEffect(currentNote) {
        currentNote?.let { note ->
            title = note.title
            content = note.content
        }
    }
    
    // Auto-save functionality
    LaunchedEffect(title, content) {
        if (title.isNotEmpty() || content.isNotEmpty()) {
            delay(1000) // Debounce auto-save
            currentNote?.let { note ->
                val updatedNote = note.copy(
                    title = title.ifEmpty { 
                        // Auto-generate title from content first line
                        content.lines().firstOrNull()?.take(50)?.trim() ?: "Untitled"
                    },
                    content = content,
                    tags = extractHashtags(content) // Auto-extract tags
                )
                viewModel.updateNote(updatedNote)
            }
        }
    }
    
    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp)
    ) {
        // Simple template selection for new notes
        if (showNoteTypeDialog && noteId == null) {
            NoteTypeDialog(
                onTypeSelected = { type ->
                    content = type.template
                    title = ""
                    showNoteTypeDialog = false
                    // Focus on title if template has content, otherwise content
                    if (type.template.isNotEmpty()) {
                        titleFocusRequester.requestFocus()
                    } else {
                        contentFocusRequester.requestFocus()
                    }
                },
                onDismiss = {
                    showNoteTypeDialog = false
                    contentFocusRequester.requestFocus()
                }
            )
        }
        
        if (isLoading) {
            Box(
                modifier = Modifier.fillMaxSize(),
                contentAlignment = Alignment.Center
            ) {
                CircularProgressIndicator()
            }
        } else {
            // Title input
            BasicTextField(
                value = title,
                onValueChange = { title = it },
                modifier = Modifier
                    .fillMaxWidth()
                    .focusRequester(titleFocusRequester),
                textStyle = TextStyle(
                    fontSize = MaterialTheme.typography.headlineSmall.fontSize,
                    fontWeight = FontWeight.Bold,
                    color = MaterialTheme.colorScheme.onSurface
                ),
                cursorBrush = SolidColor(MaterialTheme.colorScheme.primary),
                decorationBox = { innerTextField ->
                    if (title.isEmpty()) {
                        Text(
                            "Note title...",
                            style = TextStyle(
                                fontSize = MaterialTheme.typography.headlineSmall.fontSize,
                                fontWeight = FontWeight.Bold,
                                color = MaterialTheme.colorScheme.onSurfaceVariant
                            )
                        )
                    }
                    innerTextField()
                }
            )
            
            Spacer(modifier = Modifier.height(16.dp))
            
            // Content input - main text area
            BasicTextField(
                value = content,
                onValueChange = { content = it },
                modifier = Modifier
                    .fillMaxSize()
                    .focusRequester(contentFocusRequester),
                textStyle = TextStyle(
                    fontSize = MaterialTheme.typography.bodyLarge.fontSize,
                    color = MaterialTheme.colorScheme.onSurface,
                    lineHeight = MaterialTheme.typography.bodyLarge.lineHeight
                ),
                cursorBrush = SolidColor(MaterialTheme.colorScheme.primary),
                decorationBox = { innerTextField ->
                    if (content.isEmpty()) {
                        Text(
                            "Start writing...",
                            style = TextStyle(
                                fontSize = MaterialTheme.typography.bodyLarge.fontSize,
                                color = MaterialTheme.colorScheme.onSurfaceVariant
                            )
                        )
                    }
                    innerTextField()
                }
            )
        }
    }
    
    // Auto-focus on content for immediate typing (new notes)
    LaunchedEffect(noteId) {
        if (noteId == null && !showNoteTypeDialog) {
            contentFocusRequester.requestFocus()
        }
    }
}

@Composable
private fun NoteTypeDialog(
    onTypeSelected: (SimpleNoteType) -> Unit,
    onDismiss: () -> Unit
) {
    AlertDialog(
        onDismissRequest = onDismiss,
        title = { Text("Choose note type") },
        text = {
            Column {
                SimpleNoteType.values().forEach { type ->
                    TextButton(
                        onClick = { onTypeSelected(type) },
                        modifier = Modifier.fillMaxWidth()
                    ) {
                        Row(
                            modifier = Modifier.fillMaxWidth(),
                            horizontalArrangement = Arrangement.Start,
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Icon(
                                when (type) {
                                    SimpleNoteType.QUICK_NOTE -> Icons.Default.Edit
                                    SimpleNoteType.DAILY_ENTRY -> Icons.Default.Today
                                    SimpleNoteType.MEETING_NOTES -> Icons.Default.People
                                },
                                contentDescription = null,
                                modifier = Modifier.size(20.dp)
                            )
                            Spacer(modifier = Modifier.width(12.dp))
                            Text(
                                text = type.displayName,
                                style = MaterialTheme.typography.bodyLarge
                            )
                        }
                    }
                }
            }
        },
        confirmButton = {
            TextButton(onClick = onDismiss) {
                Text("Just start writing")
            }
        }
    )
}

// Auto-extract hashtags from content
private fun extractHashtags(content: String): List<String> {
    val hashtagPattern = Regex("#(\\w+)")
    return hashtagPattern.findAll(content)
        .map { it.groupValues[1].lowercase() }
        .distinct()
        .toList()
}